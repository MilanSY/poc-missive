<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>POC Missive</title>
    <script src="https://integrations.missiveapp.com/missive.js"></script>
    <style>
        body {
            font-family: -apple-system, sans-serif;
            padding: 15px;
            background: #f9f9f9;
        }

        .card {
            background: white;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .status {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 10px;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            width: 100%;
            cursor: pointer;
        }

        .log {
            font-size: 10px;
            color: #666;
            margin-top: 10px;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>

    <div class="card">
        <div class="status" id="status">üîÑ En attente de Missive...</div>
        <div id="client-info">S√©lectionnez une conversation dans Missive.</div>
        <hr>
        <button onclick="testerManuel()">Forcer la lecture</button>
        <div class="log" id="debug-log"></div>
    </div>

    <script>
        const statusEl = document.getElementById('status');
        const infoEl = document.getElementById('client-info');
        const logEl = document.getElementById('debug-log');

        function log(msg) {
            const timestamp = new Date().toLocaleTimeString();
            logEl.innerText += `\n[${timestamp}] ${msg}`;
            console.log(msg);
        }

        // R√©cup√©ration des param√®tres depuis l'URL
        const urlParams = new URLSearchParams(window.location.search);
        const urlEmail = urlParams.get('email');
        const urlName = urlParams.get('name');
        const urlId = urlParams.get('id');
        const urlToken = urlParams.get('token');

        log("üöÄ D√©marrage de l'int√©gration Missive...");
        log("üìç URL compl√®te: " + window.location.href);

        // V√©rifier si les param√®tres sont des templates non remplac√©s
        const hasTemplates = urlToken?.includes('{{') || urlEmail?.includes('{{');

        if (hasTemplates) {
            log("‚ö†Ô∏è Variables Missive non remplac√©es - L'int√©gration n'est peut-√™tre pas bien configur√©e");
            log("üí° Dans Missive: Settings > Integrations > Cr√©er une nouvelle int√©gration iframe");
        }

        log("üì• Param√®tres URL:");
        log("  - Token: " + (urlToken && !hasTemplates ? "‚úÖ Pr√©sent" : "‚ùå Absent"));
        log("  - Email: " + (urlEmail || "Non fourni"));
        log("  - Name: " + (urlName || "Non fourni"));
        log("  - ID: " + (urlId || "Non fourni"));

        // Si on a les infos depuis l'URL, les afficher directement
        if (urlEmail && !hasTemplates) {
            statusEl.innerText = "‚úÖ Donn√©es depuis URL";
            statusEl.style.color = "green";
            infoEl.innerHTML = `
                <strong>Client:</strong> ${urlName || 'Non sp√©cifi√©'}<br>
                <strong>Email:</strong> ${urlEmail}<br>
                <strong>Conversation ID:</strong> ${urlId || 'Non fourni'}
            `;
            log("‚úÖ Informations r√©cup√©r√©es depuis l'URL");
        }

        // Fonction pour obtenir l'email et les infos du contact
        function getContactInfo(conversation) {
            // Essayer de r√©cup√©rer l'email depuis diff√©rentes sources
            let email = null;
            let name = null;

            // 1. Depuis le contact s'il existe
            if (conversation.contact) {
                email = conversation.contact.emails?.[0] || null;
                name = conversation.contact.name || null;
            }

            // 2. Depuis le dernier message
            if (!email && conversation.messages && conversation.messages.length > 0) {
                const latestMsg = conversation.messages[conversation.messages.length - 1];
                if (latestMsg.from_field) {
                    email = latestMsg.from_field.address;
                    name = latestMsg.from_field.name;
                }
            }

            // 3. Depuis les participants
            if (!email && conversation.participants && conversation.participants.length > 0) {
                const participant = conversation.participants[0];
                email = participant.email || participant.address;
                name = participant.name;
            }

            return { email, name };
        }

        // √âcouter les changements de conversation
        Missive.on('change:conversations', (conversations) => {
            log("üì® √âv√©nement 'change:conversations' re√ßu");
            log("Type re√ßu: " + typeof conversations);
            log("Donn√©es: " + JSON.stringify(conversations, null, 2));

            // Si on re√ßoit des IDs (strings) au lieu d'objets
            if (conversations && conversations.length > 0 && typeof conversations[0] === 'string') {
                const conversationId = conversations[0];
                log("üìå Re√ßu ID de conversation: " + conversationId);
                log("üîÑ Tentative de r√©cup√©ration des d√©tails avec fetchConversation()...");

                // Utiliser fetchConversation pour obtenir les d√©tails
                Missive.fetchConversation(conversationId)
                    .then(conversation => {
                        log("‚úÖ D√©tails de conversation r√©cup√©r√©s!");
                        log("Conversation compl√®te: " + JSON.stringify(conversation, null, 2));

                        if (conversation) {
                            updateDisplay([conversation]);
                        } else {
                            log("‚ö†Ô∏è fetchConversation a retourn√© null");
                        }
                    })
                    .catch(err => {
                        log("‚ùå Erreur fetchConversation: " + err.message);
                        statusEl.innerText = "‚ö†Ô∏è Impossible de r√©cup√©rer les d√©tails";
                        statusEl.style.color = "orange";
                        infoEl.innerHTML = `
                            <strong>Conversation ID:</strong> ${conversationId}<br>
                            <em>Erreur: ${err.message}</em>
                        `;
                    });
                return;
            }

            updateDisplay(conversations);
        });

        function updateDisplay(conversations) {
            // V√©rifier si on a des conversations valides
            if (!conversations || conversations.length === 0) {
                log("‚ö†Ô∏è Aucune conversation");
                return;
            }

            // Filtrer les conversations null
            const validConversations = conversations.filter(c => c !== null && c !== undefined && typeof c === 'object');

            if (validConversations.length === 0) {
                log("‚ö†Ô∏è Aucune conversation valide (objets)");
                return;
            }

            const conv = validConversations[0];
            log("üìã Conversation trouv√©e:");
            log("  Type: " + typeof conv);
            log("  ID: " + conv.id);
            log("  Subject: " + (conv.subject || 'Sans sujet'));

            const { email, name } = getContactInfo(conv);

            statusEl.innerText = "‚úÖ Connect√© via API Missive";
            statusEl.style.color = "green";

            infoEl.innerHTML = `
                <strong>Client:</strong> ${name || 'Non sp√©cifi√©'}<br>
                <strong>Email:</strong> ${email || 'Non trouv√©'}<br>
                <strong>Conversation ID:</strong> ${conv.id}<br>
                <strong>Sujet:</strong> ${conv.subject || 'Sans sujet'}
            `;

            if (email) {
                log("‚úÖ Email trouv√©: " + email);
            } else {
                log("‚ö†Ô∏è Aucun email dans cette conversation");
            }
        }

        function testerManuel() {
            log("üîç Test manuel lanc√©...");
            // Utilise la nouvelle API pour r√©cup√©rer le contexte
            Missive.fetchConversations().then((conversations) => {
                log("‚úÖ fetchConversations r√©ponse:");
                log("  Type: " + typeof conversations);
                log("  Length: " + (conversations ? conversations.length : 'null'));
                log("  Contenu: " + JSON.stringify(conversations, null, 2));
                updateDisplay(conversations);
            }).catch(err => {
                log("‚ùå Erreur fetchConversations: " + err.message);
                statusEl.innerText = "‚ùå Erreur de connexion";
                statusEl.style.color = "red";
                console.error(err);
            });
        }

        // Charger automatiquement au d√©marrage
        log("üì° Tentative de chargement initial...");
        setTimeout(() => {
            testerManuel();
        }, 500);
    </script>
</body>

</html>